---
title: "The 'jack' package: Jack polynomials"
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- badges: start -->
[![R-CMD-check](https://github.com/stla/jackR/workflows/R-CMD-check/badge.svg)](https://github.com/stla/jackR/actions)
<!-- badges: end -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

```{r}
library(jack)
library(microbenchmark)
```

As of version 2.0.0, the Jack polynomials can be calculated with Julia. The 
speed is amazing:

```{r}
julia <- Jack_julia()
x <- c(1/2, 2/3, 1, 2/3, -1, -2, 1)
lambda <- c(5, 3, 2, 2, 1)
alpha <- 3
microbenchmark(
      R = Jack(x, lambda, alpha),
  Julia = julia$Jack(x, lambda, alpha),
  times = 5
)
```

`Jack_julia()` returns a list of functions. `ZonalPol`, `ZonalQPol` and 
`SchurPol` always return an exact expression of the polynomial, i.e. with 
rational coefficients (integers for `SchurPol`). If you want an exact 
expression with `JackPol`, you have to give a rational number for the argument 
`alpha`, as a character string:

```{r}
JP <- julia$JackPol(m = 2, lambda = c(3, 1), alpha = "2/5")
JP
```

To evaluate a polynomial, use `as.function`:

```{r}
jp <- as.function(JP)
```

You can provide the values of the variables of this function as numbers or 
character strings:

```{r}
jp(2, "3/2")
```

The evaluation is performed by the **Ryacas** package. If you want to 
substitute a variable with a complex number, use a character string which 
represents this number, with `I` denoting the imaginary unit:

```{r}
jp("2 + 2*I", "2/3")
```

Two functions are provided to print the polynomials with an exact expression:

```{r}
prettyForm(JP)
```

```{r}
toLaTeX(JP)
```

You can also use the functions `JackPol`, `ZonalPol`, `ZonalQPol` and 
`SchurPol` without passing by `Jack_julia()`. They are implemented in R. 
To get an exact symbolic polynomial with `JackPol`, you have to supply a 
`bigq` rational number for the parameter `alpha`:

```{r}
jpol <- JackPol(2, lambda = c(3, 1), alpha = gmp::as.bigq("2/5"))
jpol
```

This is a `gmpoly` object, from the [gmpoly](https://github.com/stla/gmpoly) 
package.

```{r}
gmpoly::gmpolyEval(jpol, c(gmp::as.bigq("2"), gmp::as.bigq("3/2")))
```

By default, `ZonalPol`, `ZonalQPol` and `SchurPol` return exact symbolic 
polynomials.

```{r}
zpol <- ZonalPol(2, lambda = c(3, 1))
zpol
```

Again, Julia is faster:

```{r}
n <- 5
lambda <- c(4, 3, 3)
alpha <- "2/3"
alphaq <- gmp::as.bigq(alpha)
microbenchmark(
      R = JackPol(n, lambda, alphaq),
  Julia = julia$JackPol(n, lambda, alpha),
  times = 5
)
```
